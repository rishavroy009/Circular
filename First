#include <iostream>
#include <fstream>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <unistd.h>
#include <cstring>
#include <vector>

#define SHM_SIZE 10485760 // 10 MB
#define CHUNK_SIZE 1024   // 1 KB for each chunk
#define QUEUE_SIZE (SHM_SIZE / CHUNK_SIZE)

struct CircularQueue {
    char data[QUEUE_SIZE][CHUNK_SIZE];
    int head;
    int tail;
    int count;
};

void producer(const char* input_file, CircularQueue* queue) {
    std::ifstream infile(input_file, std::ios::binary);
    if (!infile) {
        std::cerr << "Error opening input file" << std::endl;
        return;
    }

    while (!infile.eof()) {
        char buffer[CHUNK_SIZE];
        infile.read(buffer, CHUNK_SIZE);
        std::streamsize bytes_read = infile.gcount();

        if (bytes_read > 0) {
            while (queue->count == QUEUE_SIZE) {
                // Wait if the queue is full
                usleep(1000);
            }
            memcpy(queue->data[queue->tail], buffer, bytes_read);
            queue->tail = (queue->tail + 1) % QUEUE_SIZE;
            queue->count++;
        }
    }

    infile.close();
}

void consumer(const char* output_file, CircularQueue* queue) {
    std::ofstream outfile(output_file, std::ios::binary);
    if (!outfile) {
        std::cerr << "Error opening output file" << std::endl;
        return;
    }

    while (true) {
        if (queue->count > 0) {
            outfile.write(queue->data[queue->head], CHUNK_SIZE);
            queue->head = (queue->head + 1) % QUEUE_SIZE;
            queue->count--;

            // End condition (specific to this example, adjust as needed)
            if (queue->count == 0 && queue->head == queue->tail) {
                break;
            }
        } else {
            // Wait if the queue is empty
            usleep(1000);
        }
    }

    outfile.close();
}

int main() {
    // Create shared memory
    key_t key = ftok("shmfile",65);
    int shmid = shmget(key, SHM_SIZE, 0666|IPC_CREAT);
    if (shmid < 0) {
        std::cerr << "Failed to create shared memory" << std::endl;
        return 1;
    }

    // Attach to the shared memory
    CircularQueue* queue = static_cast<CircularQueue*>(shmat(shmid, (void*)0, 0));
    if (queue == (void*)-1) {
        std::cerr << "Failed to attach shared memory" << std::endl;
        return 1;
    }

    // Initialize the queue
    queue->head = 0;
    queue->tail = 0;
    queue->count = 0;

    // Fork a process for producer and consumer
    pid_t pid = fork();
    if (pid < 0) {
        std::cerr << "Fork failed" << std::endl;
        return 1;
    } else if (pid == 0) {
        // Child process: producer
        producer("input.dat", queue);
        exit(0);
    } else {
        // Parent process: consumer
        consumer("output.dat", queue);

        // Wait for the producer to finish
        wait(NULL);

        // Detach from shared memory
        shmdt(queue);

        // Destroy the shared memory
        shmctl(shmid, IPC_RMID, NULL);
    }

    return 0;
}
