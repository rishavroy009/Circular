#include <iostream>
#include <fstream>
#include <cstring>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

#define SHARED_MEMORY_NAME "/shared_memory"
#define QUEUE_SIZE 1024  // Buffer size for reading and writing
#define MAX_DATA_SIZE 1024 * 1024 * 10  // 10 MB

struct CircularQueue {
    char data[MAX_DATA_SIZE];
    int head;
    int tail;
    int size;
};

void initQueue(CircularQueue* queue) {
    queue->head = 0;
    queue->tail = 0;
    queue->size = 0;
}

bool isQueueFull(CircularQueue* queue) {
    return queue->size == MAX_DATA_SIZE;
}

bool isQueueEmpty(CircularQueue* queue) {
    return queue->size == 0;
}

void enqueue(CircularQueue* queue, const char* buffer, int size) {
    int remainingSpace = MAX_DATA_SIZE - queue->size;
    int writeSize = (size < remainingSpace) ? size : remainingSpace;
    int firstChunk = (queue->tail + writeSize <= MAX_DATA_SIZE) ? writeSize : MAX_DATA_SIZE - queue->tail;
    int secondChunk = writeSize - firstChunk;

    memcpy(queue->data + queue->tail, buffer, firstChunk);
    if (secondChunk > 0) {
        memcpy(queue->data, buffer + firstChunk, secondChunk);
    }
    queue->tail = (queue->tail + writeSize) % MAX_DATA_SIZE;
    queue->size += writeSize;
}

int dequeue(CircularQueue* queue, char* buffer, int size) {
    int availableData = queue->size;
    int readSize = (size < availableData) ? size : availableData;
    int firstChunk = (queue->head + readSize <= MAX_DATA_SIZE) ? readSize : MAX_DATA_SIZE - queue->head;
    int secondChunk = readSize - firstChunk;

    memcpy(buffer, queue->data + queue->head, firstChunk);
    if (secondChunk > 0) {
        memcpy(buffer + firstChunk, queue->data, secondChunk);
    }
    queue->head = (queue->head + readSize) % MAX_DATA_SIZE;
    queue->size -= readSize;

    return readSize;
}

void producer(const char* filename) {
    int shm_fd = shm_open(SHARED_MEMORY_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) {
        perror("shm_open");
        exit(1);
    }

    ftruncate(shm_fd, sizeof(CircularQueue));
    CircularQueue* queue = (CircularQueue*)mmap(0, sizeof(CircularQueue), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (queue == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }

    if (queue->size == 0 && queue->head == 0 && queue->tail == 0) {
        initQueue(queue);
    }

    std::ifstream inputFile(filename, std::ios::in | std::ios::binary);
    if (!inputFile.is_open()) {
        std::cerr << "Error opening file" << std::endl;
        exit(1);
    }

    char buffer[QUEUE_SIZE];
    while (inputFile) {
        inputFile.read(buffer, QUEUE_SIZE);
        std::streamsize bytesRead = inputFile.gcount();
        while (bytesRead > 0) {
            int chunkSize = (bytesRead < QUEUE_SIZE) ? bytesRead : QUEUE_SIZE;
            enqueue(queue, buffer, chunkSize);
            bytesRead -= chunkSize;
        }
    }

    inputFile.close();
    munmap(queue, sizeof(CircularQueue));
    close(shm_fd);
}

void consumer(const char* outputFilename) {
    int shm_fd = shm_open(SHARED_MEMORY_NAME, O_RDWR, 0666);
    if (shm_fd == -1) {
        perror("shm_open");
        exit(1);
    }

    CircularQueue* queue = (CircularQueue*)mmap(0, sizeof(CircularQueue), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (queue == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }

    std::ofstream outputFile(outputFilename, std::ios::out | std::ios::binary);
    if (!outputFile.is_open()) {
        std::cerr << "Error opening file" << std::endl;
        exit(1);
    }

    char buffer[QUEUE_SIZE];
    while (true) {
        int bytesRead = dequeue(queue, buffer, QUEUE_SIZE);
        if (bytesRead > 0) {
            outputFile.write(buffer, bytesRead);
        } else if (isQueueEmpty(queue)) {
            break;
        }
    }

    outputFile.close();
    munmap(queue, sizeof(CircularQueue));
    close(shm_fd);
}

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <producer|consumer> <filename>" << std::endl;
        return 1;
    }

    if (strcmp(argv[1], "producer") == 0) {
        producer(argv[2]);
    } else if (strcmp(argv[1], "consumer") == 0) {
        consumer(argv[2]);
    } else {
        std::cerr << "Invalid argument: " << argv[1] << std::endl;
        return 1;
    }

    return 0;
}
