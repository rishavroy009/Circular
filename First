#include <iostream>
#include <fstream>
#include <fcntl.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <thread>
#include <semaphore.h>

#define SHM_SIZE 10485760 // 10 MB

struct shared_data {
  char data[SHM_SIZE]; // Shared memory segment to hold data chunks
  int prod_idx;        // Index for producer to add data
  int cons_idx;        // Index for consumer to read data
  bool full;           // Flag to indicate if queue is full
  bool empty;          // Flag to indicate if queue is empty
  sem_t mutex;         // Semaphore for mutual exclusion
  sem_t empty_sem;     // Semaphore for empty slot
  sem_t full_sem;      // Semaphore for full slot
};

void producer(const char* filename, shared_data* shm_ptr) {
  std::ifstream infile(filename, std::ios::binary);
  int bytes_read;
  char buffer[4096]; // Buffer to read data in chunks

  // Initialize semaphores (full initialized to 1, empty to 0)
  sem_init(&(shm_ptr->mutex), 0, 1);
  sem_init(&(shm_ptr->empty_sem), 0, 0);
  sem_init(&(shm_ptr->full_sem), 0, 1);

  while ((bytes_read = infile.read(buffer, sizeof(buffer)).gcount()) > 0) {
    // Wait for empty slot
    sem_wait(&(shm_ptr->empty_sem));

    // Lock shared memory for mutual exclusion
    sem_wait(&(shm_ptr->mutex));

    // Copy data to shared memory
    memcpy(shm_ptr->data + shm_ptr->prod_idx, buffer, bytes_read);
    shm_ptr->prod_idx = (shm_ptr->prod_idx + bytes_read) % SHM_SIZE;

    // Update flags
    shm_ptr->empty = false;
    shm_ptr->full = (shm_ptr->prod_idx == shm_ptr->cons_idx);

    // Unlock shared memory
    sem_post(&(shm_ptr->mutex));

    // Signal full slot
    sem_post(&(shm_ptr->full_sem));
  }

  infile.close();
  sem_close(&(shm_ptr->mutex));
  sem_close(&(shm_ptr->empty_sem));
  sem_close(&(shm_ptr->full_sem));
}

void consumer(const char* outfile, shared_data* shm_ptr) {
  std::ofstream outfile_stream(outfile, std::ios::binary);
  int bytes_written = 0;
  char buffer[4096];

  // Initialize semaphores (full initialized to 1, empty to 0)
  sem_init(&(shm_ptr->mutex), 0, 1);
  sem_init(&(shm_ptr->empty_sem), 0, 0);
  sem_init(&(shm_ptr->full_sem), 0, 1);

  while (true) {
    // Wait for full slot
    sem_wait(&(shm_ptr->full_sem));

    // Lock shared memory for mutual exclusion
    sem_wait(&(shm_ptr->mutex));

    // Copy data from shared memory
    int bytes_to_copy = (SHM_SIZE - shm_ptr->cons_idx < SHM_SIZE - shm_ptr->prod_idx) ?
                        SHM_SIZE - shm_ptr->cons_idx : SHM_SIZE - shm_ptr->prod_idx;
    bytes_to_copy = std::min(bytes_to_copy, sizeof(buffer));
    memcpy(buffer, shm_ptr->data + shm_ptr->cons_idx, bytes_to_copy);
    outfile_stream.write(buffer, bytes_to_copy);
    bytes_written += bytes_to_copy;
    shm_ptr->cons_idx = (shm_ptr->cons_idx + bytes_to_copy) % SHM_SIZE;

    // Update flags
    shm_ptr->full = false;
    shm_ptr->empty = (shm_ptr->cons_idx == shm_
