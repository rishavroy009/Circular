#include <iostream>
#include <fstream>
#include <cstring>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

#define SHARED_MEMORY_NAME "/shared_memory"
#define BUFFER_SIZE 1024  // Buffer size for reading and writing
#define MAX_DATA_SIZE 1024 * 1024 * 10  // 10 MB

struct CircularQueue {
    char data[MAX_DATA_SIZE];
    int head;
    int tail;
    int size;
    bool producer_done; // Flag to indicate producer is done
};

void initQueue(CircularQueue* queue) {
    queue->head = 0;
    queue->tail = 0;
    queue->size = 0;
    queue->producer_done = false;
}

bool isQueueFull(CircularQueue* queue) {
    return queue->size == MAX_DATA_SIZE;
}

bool isQueueEmpty(CircularQueue* queue) {
    return queue->size == 0;
}

void enqueue(CircularQueue* queue, const char* buffer, int size) {
    if (isQueueFull(queue)) {
        return;
    }

    int space_left = MAX_DATA_SIZE - queue->size;
    int write_size = (size < space_left) ? size : space_left;

    int first_chunk_size = (queue->tail + write_size <= MAX_DATA_SIZE) ? write_size : MAX_DATA_SIZE - queue->tail;
    int second_chunk_size = write_size - first_chunk_size;

    memcpy(queue->data + queue->tail, buffer, first_chunk_size);
    memcpy(queue->data, buffer + first_chunk_size, second_chunk_size);

    queue->tail = (queue->tail + write_size) % MAX_DATA_SIZE;
    queue->size += write_size;
}

int dequeue(CircularQueue* queue, char* buffer, int size) {
    if (isQueueEmpty(queue)) {
        return 0;
    }

    int read_size = (size < queue->size) ? size : queue->size;

    int first_chunk_size = (queue->head + read_size <= MAX_DATA_SIZE) ? read_size : MAX_DATA_SIZE - queue->head;
    int second_chunk_size = read_size - first_chunk_size;

    memcpy(buffer, queue->data + queue->head, first_chunk_size);
    memcpy(buffer + first_chunk_size, queue->data, second_chunk_size);

    queue->head = (queue->head + read_size) % MAX_DATA_SIZE;
    queue->size -= read_size;

    return read_size;
}

void producer(const char* filename) {
    int shm_fd = shm_open(SHARED_MEMORY_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) {
        perror("shm_open");
        exit(1);
    }

    ftruncate(shm_fd, sizeof(CircularQueue));

    CircularQueue* queue = (CircularQueue*)mmap(0, sizeof(CircularQueue), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (queue == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }

    if (queue->size == 0 && queue->head == 0 && queue->tail == 0) {
        initQueue(queue);
    }

    std::ifstream inputFile(filename, std::ios::in | std::ios::binary);
    if (!inputFile.is_open()) {
        std::cerr << "Error opening file" << std::endl;
        exit(1);
    }

    char buffer[BUFFER_SIZE];
    while (inputFile.read(buffer, BUFFER_SIZE)) {
        std::streamsize bytesRead = inputFile.gcount();
        while (bytesRead > 0) {
            if (!isQueueFull(queue)) {
                int chunkSize = (bytesRead < BUFFER_SIZE) ? bytesRead : BUFFER_SIZE;
                enqueue(queue, buffer, chunkSize);
                bytesRead -= chunkSize;
            }
        }
    }

    // Final read to ensure all remaining data is enqueued
    if (inputFile.gcount() > 0) {
        enqueue(queue, buffer, inputFile.gcount());
    }

    queue->producer_done = true;  // Indicate producer is done
    inputFile.close();
    munmap(queue, sizeof(CircularQueue));
    close(shm_fd);
}

void consumer(const char* outputFilename) {
    int shm_fd = shm_open(SHARED_MEMORY_NAME, O_RDWR, 0666);
    if (shm_fd == -1) {
        perror("shm_open");
        exit(1);
    }

    CircularQueue* queue = (CircularQueue*)mmap(0, sizeof(CircularQueue), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (queue == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }

    std::ofstream outputFile(outputFilename, std::ios::out | std::ios::binary);
    if (!outputFile.is_open()) {
        std::cerr << "Error opening file" << std::endl;
        exit(1);
    }

    char buffer[BUFFER_SIZE];
    while (!queue->producer_done || !isQueueEmpty(queue)) {
        int bytesRead = dequeue(queue, buffer, BUFFER_SIZE);
        if (bytesRead > 0) {
            outputFile.write(buffer, bytesRead);
        }
    }

    outputFile.close();
    munmap(queue, sizeof(CircularQueue));
    close(shm_fd);
    shm_unlink(SHARED_MEMORY_NAME);  // Clean up shared memory
}

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <producer|consumer> <filename>" << std::endl;
        return 1;
    }

    if (strcmp(argv[1], "producer") == 0) {
        producer(argv[2]);
    } else if (strcmp(argv[1], "consumer") == 0) {
        consumer(argv[2]);
    } else {
        std::cerr << "Invalid argument: " << argv[1] << std::endl;
        return 1;
    }

    return 0;
}
