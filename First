#include <iostream>
#include <fstream>
#include <cstring>
#include <fcntl.h> 
#include <sys/mman.h>
#include <unistd.h>
#include <semaphore.h>
#include <sys/stat.h>

#define SHM_NAME "/my_shared_memory"
#define QUEUE_SIZE 1048576 // 1MB buffer for the circular queue
#define SHM_SIZE (sizeof(CircularQueue)) // Size for the shared memory segment

struct CircularQueue {
    size_t head;
    size_t tail;
    size_t size;
    char buffer[QUEUE_SIZE];
};

bool isFull(CircularQueue* queue) {
    return ((queue->head + 1) % queue->size) == queue->tail;
}

bool isEmpty(CircularQueue* queue) {
    return queue->head == queue->tail;
}

void enqueue(CircularQueue* queue, char data) {
    if (!isFull(queue)) {
        queue->buffer[queue->head] = data;
        queue->head = (queue->head + 1) % queue->size;
    }
}

char dequeue(CircularQueue* queue) {
    if (!isEmpty(queue)) {
        char data = queue->buffer[queue->tail];
        queue->tail = (queue->tail + 1) % queue->size;
        return data;
    }
    return '\0';
}

void producer(const char* input_file) {
    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) {
        perror("shm_open");
        exit(EXIT_FAILURE);
    }

    if (ftruncate(shm_fd, SHM_SIZE) == -1) {
        perror("ftruncate");
        exit(EXIT_FAILURE);
    }

    CircularQueue* queue = (CircularQueue*) mmap(0, SHM_SIZE, PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (queue == MAP_FAILED) {
        perror("mmap");
        exit(EXIT_FAILURE);
    }

    queue->head = 0;
    queue->tail = 0;
    queue->size = QUEUE_SIZE;

    std::ifstream infile(input_file, std::ios::binary);
    if (!infile.is_open()) {
        perror("ifstream");
        exit(EXIT_FAILURE);
    }

    char ch;
    while (infile.get(ch)) {
        while (isFull(queue)) {
            // Busy wait or use semaphore
        }
        enqueue(queue, ch);
    }

    infile.close();
    munmap(queue, SHM_SIZE);
    close(shm_fd);
}

void consumer(const char* output_file) {
    int shm_fd = shm_open(SHM_NAME, O_RDONLY, 0666);
    if (shm_fd == -1) {
        perror("shm_open");
        exit(EXIT_FAILURE);
    }

    CircularQueue* queue = (CircularQueue*) mmap(0, SHM_SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);
    if (queue == MAP_FAILED) {
        perror("mmap");
        exit(EXIT_FAILURE);
    }

    std::ofstream outfile(output_file, std::ios::binary);
    if (!outfile.is_open()) {
        perror("ofstream");
        exit(EXIT_FAILURE);
    }

    while (true) {
        while (isEmpty(queue)) {
            // Busy wait or use semaphore
        }
        char ch = dequeue(queue);
        outfile.put(ch);
        if (queue->head == queue->tail) break;
    }

    outfile.close();
    munmap(queue, SHM_SIZE);
    close(shm_fd);
    shm_unlink(SHM_NAME);
}

int main(int argc, char* argv[]) {
    if (argc != 4) {
        std::cerr << "Usage: " << argv[0] << " <producer|consumer> <input_file> <output_file>" << std::endl;
        return 1;
    }

    std::string role = argv[1];
    const char* input_file = argv[2];
    const char* output_file = argv[3];

    if (role == "producer") {
        producer(input_file);
    } else if (role == "consumer") {
        consumer(output_file);
    } else {
        std::cerr << "Unknown role: " << role << std::endl;
        return 1;
    }

    return 0;
}
